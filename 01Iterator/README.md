무엇을 이터레이터라 할 수 있는가?

```java
for(int i = 0; i < arr.length; i++) {
System.out.printIn(arr[i]);
}
```

여기서 변수 i의 기능을 추상화해서 일반화한 것을 이터레이터패턴이라고 한다.


## 독자의 사고를 넓히기 위한 힌트

#### 구현에 상관없이 Iterator를 사용할 수 있다.

왜 Iterator패턴 같은 조금은 번거로운 패턴을 사용할까? 배열이라면 for문을 이용해서 빙글빙글
돌리면 좋을 텐데, 왜 집합체의 외부에 Iterator역할 같은 것을 만들어야 할까요?

가장 큰 이유는 Iteraotor를 사용함으로써 구현과 분리해서 하나씩 셀 수 있기 때문

#### 추상 클래스나 인터페이스는 아무리 해도 서툴룬데

추상 클래스나 인터페이스의 사용법을 잘 모르는 사람은 Aggregate 인터페이스나
Iterator 인터페이스를 사용하지 않고, 갑자기 ConcreateAggregate 역할이나
ConcreateIterator 역할을 사용해서 프로그래밍 하기 쉽습니다.
모든 문제를 구체적인 클래스만으로 해결하고자 하는 욕심이 앞서기 때문입니다

 그러나 구체적인 클래스만 사용하면 클래스 간의 결합이 강해져서, 부품으로 재이용하는 일이 어렵습니다.
결합을 약하게 해서 부품으로 재이용하기 쉽도록 하기 위해 추상 클래스나 인터페이스가 도입됩니다.

### "구체적인 클래스만으로 프로그래밍하는 것이 아니라, 추상 클래스나 인터페이스를 사용해 프로그래밍을 한다."

#### Aggregate와 Iterator의 대응
그런데 BookShelf 클래스에 대응하는 ConcreateIterator 역할로서 BookShelfIterator클래스를 정의했던 일을 상기해야 합니다.

#### 'next'는 틀리기 쉽다
**next** 라는 이름의 메소드는 틀리기 쉽습니다. 이 메소드의 반환값은 현재 처리되고 있는 요소일까요?
아니면 다음 요소 일까요?
즉, '현재의 요소를 반환하면서 다음 위치로 진행'

#### 'hasNext'는 틀리기 쉽다

#### 복수의 Iterator
'하나씩 나열하는 구조가 Aggregate 역할의 외부에 놓여있다.'라는 것은 Iterator 패턴의 특징 중에 하나입니다.
이 특징으로 인해 하나의 ConcreateAggregate 역할에 대해서 복수의 ConcreateIteraotor역할을 만들 수 있습니다.

#### Iterator의 다양한 종류
예제 프로그램에서 작성한 Iterator클래스는 정방향으로 한번만 검색하는 단순한 것이였지만 검색에는 다양한 종류가 있습니다

- 뒤에서 시작해서 역방향으로 진행한다.
- 정방향으로도 역방향으로도 진행한다.
- 번호를 지정해서 갑자기 그곳으로 점프한다.

#### deleteIterator는 필요 없다.