#동일시 하기

# Composite (그릇과 내용물 동일시 하기)

컴퓨터의 파일 시스템에는 '디렉토리'라는 것이 있습니다. 디렉터리 안에는 파일이 있거나 다른 디렉터리가 있기도 합니다. 또 그 하위 디렉토리 안에는 다른 파일이나 하위 디렉터리가 있기도 합니다. 디렉터리는 이와 같이 '상자 안의 상자'로 된 구조, 즉 재귀적인 구조를 만들어 냅니다.

디렉터리와 파일은 서로 다르지만 모두 '디렉터리 안에 넣을 수 있는 것'입니다. 디렉터리와 파일을 합쳐서 '디렉터리 엔트리'라고 부르기도 합니다. 디렉터리 엔트리라는 이름으로 디렉터리와 파일을 같은 종류로 간주하고(동일시하고) 있습니다.

예들 들어, 어떤 디렉터리 안에 무엇이 있는지를 차례대로 조사한다고 가정합니다. 이때, 차례로 조사하는 것은 하위 디렉터리일지도 모르고 파일일지도 모릅니다. 한마디로 말하면 '디렉터리 엔트리'를 차례대로 조사하는 것입니다.

디렉터리와 파일을 모아서 디렉터리 엔트리로 취급하듯이 그릇과 내용물을 같은 종료로 취급하면 편리한 경우가 있습니다. 그릇 안에는 내용물을 넣을 수도 있고 더욱 작은 그릇을 넣을 수도 있습니다. 그리고 그 작은 그릇 안에 더 작은 그릇을 넣을 수 있고... 이런 식으로 '상자안에 상자'처럼 된 구조, 즉 재귀적인 구조를 만들 수 있습니다.

> Composite 패턴
## 위계와 다형성을 가진 패턴이다.
**이장에서 배울 Composite패턴은 그릇과 내용물을 동일시해서 재귀적인 구조를 만들기 위한 디자인 패턴**



Entry - File과 Directroy를 동일시하는 추상 클래스  
FIle - 파일을 나타내는 클래스  
Directory - 디렉터리를 나타내는 클래스  
FileTreatmentException - 파일에 Entry를 추가하려고 할 때 발생하는 예외 클래스  
Main - 동작 테스트용 클래스

![https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Composite_UML_class_diagram_%28fixed%29.svg/960px-Composite_UML_class_diagram_%28fixed%29.svg.png](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Composite_UML_class_diagram_%28fixed%29.svg/960px-Composite_UML_class_diagram_%28fixed%29.svg.png)





**Leaf(나뭇잎)의 역할**

Leaf은 '내용물'을 표싷는 역할을 하며 내부에는 다른 것을 넣을 수 없습니다. 예제에서는 File

**Composite(복합체)의 역할**

Composite는 '그릇'을 나타내는 역할을 하며 'Leaf'역할이나 Composite역할을 넣을 수 있습니다. 예제에서는 Directory

**Component의 역할**

Leaf역할과 Composite역할을 동일시하는 역할입니다. Component는 Leaf 역할과 Composite 역할에 공통적인 상위 클래스로 실현합니다. 예제에서는 Entry

**Client의 역할**

Composite 패턴의 사용자. 예제에서는 Main



## 독자의 사고를 넓히기 위한 힌트



## 복수와 단수의 동일시

Composite 패턴은 그릇과 내용물을 동일시하는 패턴이지만, **복수와 단수 역시 동일시한다고 할 수 있습니다.** 즉, 여러 개를 모아서 마치 하나인 것처럼 취급하는 것

예를 들면 프로그램의 동작 테스트를 생각해보면, Test1에서는 키보드에서의 입력테스트를 실행하고, Test2에서는 파일에서의 입력테스트를 실행하고, Test3에서는 네트워크에서의 입력 테스를 실행한다고 가정합니다. Test1, Test2, Test3의 세 개를 합쳐서 '입력 테스트'로 하고 싶을 때 Composite 패턴을 사용할 수 있습니다. 복수의 테스트를 모아서 '입력 테스트'로 하고, 또 다른 테스트를 모아서 '출력 테스트'로 하고, 다시 이 둘을 모아 '입출력 테스트'로 합니다.

캔트백의 테스트프레임워크 입문책에서도 동일.



## Add메소드의 구현 방법

예제 프로그램에서는 Entry클래스에서 add메소드를 정의하고 예외를 제공했습니다. add메소드를 실제로 사용할 수 있는 것은 Directory 클래스 뿐입니다. add메소드의 설치와 구현에는 다양한 방법이 존재함.

경우1 : Entry클래스에서 구현하고 에러를 처리한다.

예제 프로그램에서는 add 메소드를 Entry에서 구현하고 에러로 처리했습니다. add 메소드를 실제로 사용할 수 있는 Directory 클래스에서는 Entry클래스의 add를 오버라이드해서 의미있는 구현으로 바꿔놓습니다. File 클래스는 Entry클래스에서 add메소드를 상속하기 때문에 add는 가능하지만 예외가 가능합니다.

경우2: Entry클래ㅡ에서 구현하고 아무것도 실행하지 않는다.

add 메소드는 Entry 클래스에서 구현하지만 에러로 처리하지 않는(아무것도 실행하지 않는) 방법도 있습니다.

경우3: Entry 클래스에서 선언은 하지만 구현은 하지 않는다.

add메소드를 Entry클래스에서는 추상 클래스로 하고, 하위 클래스에서는 필요하면 정의하고 필요하지 않으면 에러로 처리하는 방법이 있다. 이 방법은 일관성을 가질 수 있고 불필요한 경우의 작동을 하위 클래스에서 결정할 수 있는 장점이 있습니다. 그러나 원래 필요없는 add(경우에 따라서는 remove나 getChild 등)을 File 쪽에서 정의해야 하는 단점이 있습니다.

경우4: Directory 클래스에만 넣는다.

add메소드를 Entry 클래스에는 넣지 않고,  처음부터 정말로 필요한 Directory클래스에 넣는 방법도 있습니다. 그러나 이 방법은 Entry 형의 변수( 실제의 내용은 Directroy의 인스턴스)에 add할 때, 하나한 Directory형으로 캐스트해야하는 불편함이 있습니다.



## 재귀적 구조는 모든 장면에서 등장한다.

예제 프로그램에서는 디렉터리 엔트리를 예로 들어 설명했지만 프로그래밍을 할 때 재귀적인 구조 및 Composite패턴은 여러 장면에서 등장합니다. 예를 들면, 원도우 시스템에서는 원도우 안에 자식 원도우를 가지게 하는데 이것이 전형적인 Composite 패턴입니다.

문장의 개발 항목 안에 다시 항목이 포함되어 있는 것도 재귀적인 구조라고 할 수 있습니다. 컴퓨터에 대한 커맨드(명령)을 정리한 매크로 커맨드를 만들 때, 그 매크로 커맨드를 재귀적인 구조로 실현하면 매크로 커맨드의 매크로 커맨드도 만들 수 있습니다. 일반적으로 트리 구조로 된 데이터 주고는 Composite 패턴에 해당합니다.
