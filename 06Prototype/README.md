# 복사해서 인스턴스 만들기

Something 인스턴스를 작성할 때는 new something()이라는 식을 이용합니다
`new`라는 `Java`언어의 키워드를 사용해서 클래스 이름을 지정해 인스턴스를 만듭니다.

이와 같이 `new`로 인스턴스를 만들 경우에는 클래스 이름을 반드시 지정해야 합니다 그러나 클래스  
이름을 지정하지 않고 인스턴스를 생성할 때도 있습니다.

다음과 같은 경우에는 클래스로부터 인스턴스를 만드는 것이 아니라 인스턴스를 복사해서 새로운 인스턴스를 만듭니다.

1. 종류가 너무 많아 클래스로 정리되지 않는 경우
- 첫번째는 취급하는 오브젝트의 종류가 너무 많아서 각각을 별도의 클래스로 만들어 다수의 소스 파일을 작성해야 하는 경우입니다

2. 클래스로부터 인스턴스 생성이 어려운 경우
- 두 번째는 생성하고 싶은 인스턴스가 복잡한 작업을 거쳐 만들어지기 때문에 클래스로부터 만드리가 메우 어려운 경우입니다.

3. framework와 생성할 인스턴스를 분리하고 싶은 경우
- 세 번째는 인스턴스를 생성할 때의 framework를 특정 클래스에 의존하지 않도록 만들고 싶은 경우입니다. 이와 같은 경우에는 클래스 이름을 지정해서 인스턴스를 만드는 것이 아니라 이미 '이미 모형'이 되는 인스턴스를 등록해 두고, 그 등록된 인스턴스를 복사해서 인스턴스를 생성합니다.

인스턴스로부터 다른 인스턴스를 만드는 것은 복사기를 사용해서 서류를 복사하는 일과 비슷합니다.  
`인스턴스에서 인스턴스를 만드는 것!`



Framework

- Product
  : 해당 클래스는 Cloneable을 상속받아 복제를 가능케 한다.
- Manager
  : Product 인터페이스를 이용해서 인스턴스의 복제를 실행하는 클래스.  
  Product 인터페이스나 Manager 클래스의 소스에 MessageBox클래스나 UnderlinePen클래스의 클래스 이름이 전혀 나오지 않는 점을 주의하십시오. 클래스 이름이 나오지 않는다는 것은 Product와 Manager는 그들의 클래스와는 독립적으로 수정할 수 있다는 것을 의미합니다. 이것이 중요 포인트. **소스 안에 클래스의 이름을 쓰면 그 클래스와 밀접한 관계가 생깁니다.** Manager 클래스에서는 구체적인 개개의 클래스 이름을 쓰지 않고 단지 Product라는 인터페이스 이름만 사용하고 있습니다. 이 인터페이스만이 Manager클래스와 다른 클래스의 다리 역할을 합니다.

Anonymous

- MessageBox
- UnderlinePen
- Main




### Prototype 패턴의 등장인물

#### Prototyoe(원형)의 역할

`Prototype`은 인스턴스를 복사하여 새로운 인스턴스를 만들기 위한 메소드를 결정합니다.
예제 프록램에서는 `Product` 인터페이스가 이 역할을 합니다

#### ConcreatePrototype(구체적인 원형)의 역할

`ConcreatePrototype`은 인스턴스를 복사해서 새로운 인스턴스를 만드는 메소드를 실제로 구현합니다.
예제 프로그램에서는 `MessageBox`클래스나 `UnderlinePen`클래스가 이 역할을 합니다.

#### Client(이용자)의 역할

`Client`는 인스턴스를 복사하는 메소드를 이용해서 새로운 인스턴스를 만듭니다.
예제 프로그램에서는 `Manager` 클래스가 이 역할을 합니다.








## 독자의 사고를 넓히기 위한 힌트

1. 클래스에서 인스턴스를 만들면 안되는 것인가?

필자가 Prototype패턴을 배우고 나서
처음 느낀점은 인스턴스를 만들고 싶다면 순박하게 new Something 하면되지
"왜 Prototype 패턴이 필요할까?"하는 것이였습니다.
그 답에 대해서는 이번 장의 서두에 3가지 예

### 1.종류가 너무 많아서 클래스로 정리할 수 없는 경우
 예제 프로그램에서는 3개의 모형
 - '~'을 사용해서 문자열에 밑줄을 긋는 것
 - '*'을 사용해서 문자열에 테두리을 긋는 것
 - '/'을 사용해서 문자열에 테두리을 긋는 것
     이 에는 간단한 것이기 때문에 모형이 3개뿐이지만 마음먹기에 따라 얼마든지 많은 종류의 모형 가능
       그러나 이것은 모두 각각의 클래스로 만들면 클래스의 수가 너무 많아지기 때문에 소스 프로그램을 관리하기 힘듬

### 2.클래스로부터 인스턴스 생성이 어려운 경우
 이것은 이번 예제에서는 별로 실감할 수 없습니다. 마우스를 사용해서 도형 에디터와 같은 어플리케이션을 상상하면 이해하기 쉬울 겁니다.
 사용자가 조작을 해서 만든 도형을 나타내는 인스터늣와 같은 것을 만들고 싶다고 가정
 이 때 클래스를 사용하는 것이 아니라 인스턴스를 복사해서 만드는 방법이 간단

### 3.framework와 생성하는 인스턴스를 분리하고 싶은 경우
 예제 프로그램에서는 인스턴스의 복사(clone)를 실행하는 부분을 framework 패키지 안에 설정하고 있습니다.
 Manager 클래스의 Create 메소드에는 클래스 이름 대신에 "strong message"나 다양한 문자열을 인스턴스 생성을 위한 이름으로 제공하고 있습니다.
 이것은 Java라는 언어가 구비하고 있는 인스턴스 생성기구인 new Something()이라는 형식을 보다 넒게 이용해서 클래스 이름의 속박으로부터 framework를 분리할 수 있습니다.

2. 클래스 이름은 속박인가?
   그런데 소스 프로그램 내부에 클래스 이름이 쓰여 있으면 무엇 이 문제일까

 우리는 객체 지향 프로그래밍의 목표 중 하나가 '부품으로써 재이용'이라는 점을 상기할 필요가 있다.
 소스의 내부에 이용할 클래스의 이름을 쓰는 것은 항상 나쁜 것만은 아닙니다.
 **그러나 소스 내부에 이용할 클래스의 이름이 쓰여 있으면 그 클래스와 분리해서 재이용할 수 없게 됩니다**

 물론 소스를 고쳐서 클래스 이름을 변경할 수 있습니다. 그러나 여기에서 기술하고 있는 '부품으로써 재이용'에서 소스를 고칠 수 있는지는 중요하지 않습니다. Java에서는 비록 클래스 파일만 가지고 있더래도 그 클래스를 재이용할 수 있는지가 중요합니다.
 **다시말해 소스 파일(.java)이 없어도 재사용할 수 있는지가 포인트입니다.**

 긴밀하게 결합해야 하는 클래스 이름이 소스 안에 사용되는 것은 당연하고 문제가 없지만
  부품으로서 독립시켜야 하는 클래스 이름이 소스 안에 사용되는 것이 문제가 됩니다.


## JAVA언어의 clone
 Java언어에서는 인스턴스의 복사를 실행하는 도구로 clone 메소드가 준비되어 있습니다.
 clone 메소드를 실행할 경우에는 **복사 대상이 되는 클래스는 java.lang.Cloneable 인터페이스를 구현할 필요가 있다.**
 복사 대상이 되는 클래스가 직접 `java.lang.Clonable`인터페이스를 구현해도 상관없고  
 하위 클래스의 어딘가에서 Cloneable 인터페이스를 구현해도 상관 없습니다.
   
 예제 프로그램에서는 messageBox 클래스나 UnderlinePen 클래스가 Product 인터페이스를 구현하고, 그 Product 인터페이스는 Cloneable 인터페이스의 하위 인터페이스를 구성  

 Cloneable 인터페이스를 구현한 클래스의 인스턴스는 clone 메소드를 호출하면 복사합니다.
  그리고 clone 메소드의 반환값은 복사해서 만들어진 인스턴스가 됩니다.(내부에서 하는 일은 원래의 인스턴스와 같은 크기의 메모리를 확보해서, 그 인스턴스의 필드 내용을 복사하는 것입니다.)
 만약 Clonable 인터페이스를 구현하지 않는 클래스의 인스턴스가 clone 메소드를 호출하면 예외 `CloneNotSupportedException`이 발생합니다

 ~~ Cloneable 인터페이스를 구현하고 있는 클래스의 인스턴스
 -> 복사된다.
 ~~ Cloneable 인터페이스를 구현하고 있지 않는 클래스의 인스턴스
 -> CloneNotSupportedException 이 발생

## clone 메소드는 어디에서 정의되는 걸까?
clone 메소드는 java.lang.Object 클래스에서 정의. Object 클래스는 Java의 클래스 계층의 기본 클래스이기 때문에
어느 클래스에서도 clone메소드를 상송하게 됩니다

## cloneable 이 요구하는 메소드는?
 'Cloneable 인터페이스'라고 하면 그 내부에 clone메소드가 선언되어 있는 것처럼 생각하기 쉽다.
 그러나 Cloneable 인터페이스에는 메소드가 하나도 선언되어 있지 않습니다.
 이 인터페이스는 단지 'clone에 의해 복사할 수 있다'라는 표시로서 사용되고 있습니다.
 이와 같은 표시를 하는 인터페이스를 maker interface라고 합니다.

## clone 메소드는 피상적인 복사를 실행한다.
 clone 메소드에 의해 이루어지는 것은 필드의 내용을 그대로 복사한다는 동작입니다. 바꾸어 말하면 필드의 앞에 있는 인스턴스의 내용까지는 고려하지 않는 것
 예를 들어 필드 앞에 배열이 있었다고 가정합시다. clone 메소드를 사용해서 복사를 한 경우 그 배열에 대한 참조만 복사될 뿐이고
 배열의 요소 하나하나가 복사되는 것은 아니다.
 이와 같은 필드 대 필드의 복사 '피상적인 복사'라고 합니다. clone 메소드가 실행하는 것은 '피상적인 복사'입니다.
 clone이 수행하는 '피상적인  복사'만으로 곤란한 경우에는 클래스 설계자가 clone메소드를 오버라이드해서 자신이 필요한
 '복사'를 정의할 수도 있습니다.(clone 메소드를 오버라이드하는 경우에는 super.clone()을 사용한 상위 클래스의 clone메소드의 호출을 잊지말아야합니다.)

 clone은 복사하를 할 뿐아며 생성자를 호출하는 것이 아니라는 점에 주의할 필요가 있습니다
 또한 인스턴스 생성 시에 무엇인가 특수한 초기화를 필요로 하는 클래스에서는 clone메소드안에 처리를 기술할 필요가 있습니다.


