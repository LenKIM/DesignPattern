# Proxy 패턴

'대리인' 이라는 의미. 대리인이란 일을 해야 할 본인을 대신(대리)하는 사람입니다. 본인이 아니라도 가능한 일을 맡기기 위해서 대리인을 세웁니다. 대리인은 어디까지나 대리에 지나지 않기 때문에 할 수 있는 일에는 한계가 이습니다. 대리인이 할 수 있는 범위를 넘는 일이 발생하면, 대리인은 본인한테 와서 상담을 합니다.

오브젝트(객체)지향에서는  '본인'도 '대리인'도 오브젝트(객체)가 됩니다. 바빠서 일을 할 수 없는 본인 프로젝트 대신에 대리인 오브젝트가 어느 정보 일을 처리게 합니다.



## Proxy 패턴의 등장인물

### Subject의 역할

Proxy역할과 RealSubject 역할을 동일시하기 위한 인터페이스(API)를 결정합니다. Subject역할이 있는 덕분에 Client역할과 RealSubject 역할의 차이를 의식할 필요가 없습니다. 예제 프로그램에서는 Printable인터페이스가 이 역할을 합니다.

### Proxy(대리인)의 역할

Proxy 역할은 CLient 역할의 요구를 할 수 있는 만큼 처리를 합니다. 만약, 자신만으로 처리할 숭 없으면 Proxy역할은 RealSubject역할에게 처리를 맡깁니다 .Prxoy 역할은 정말로 RealSubject역할이 필요해지면 그때 RealSubject 역할을 생성합니다. Proxy 역할은 Subject역할에서 정해지는 인터페이스(API)를 구현합니다. 예제 프로그램에서는 PrinterProxy 클래스가 이 역할을 합니다.

### RealSubject(실체의 주체)의 역할

'대리인'인 Proxy역할에서 감당할 수 없는 일이 발생했을 때 등장하는 것이 '본인'인 RealSubject 역할입니다. 이 역할도 Proxy역할과 마찬가지로 Subject역할에서 정해져 있는 인터페이스(APi)를 구현합니다. 예제에서는 Printert 클래스가 이 역할

### Client(의뢰인)의 역할

Proxy패턴을 이용하는 역할





### 대리인을 사용해서 속도 올리기

Proxy패턴에서는 Proxy 역할이 대리인이 되어 가능한 일만 처리를 대신합니다. 예를 들어, 예제 프로그램에서는 Prxoy 역할을 사용해서 실제로 printer할 때까지 무거운 처리를 지연시킬 수 있었습니다.

이 예제 프로그램에서는 무거운 처리라고 해봐야 뻔한 일이기 때문에 별로 도움이 되지 않습니다. 그러나 초기화에 시간이 걸리는 기능이 많이 존재하는 대규모 시스템을 생각해보십시오. 기동 시점에서는 이용하지 않는 기능까지 전부 초기화하면, 어플리케이션의 기동에 시간이 많이 걸리는 문제가 발생, 이러면 사용자가 불만을 느끼게 됩니다. 따라서 실제로 그 기능을 사용할 단계가 되어 처음으로 초기화를 하는 편이 사용자의 스트레스를 줄여주는 방법이 될 것입니다.



### 대리인과 본인을 분리할 필요가 있는가?

PrinterProxy 클래스와 Printer 클래스로 분리하지 않고 Printer클래스 안에 처음부터 지연평가의 기능(필요하게 되면 그때 인스턴스를 생성하는 기능)을 넣을 수도 있습니다. 그러나 Proxy 역할과 RealSubject 역할을 분리해서 프로그램의 부품화를 만들면, 개별적으로 수정을 할 수 있습니다.(분할 통치)

PrinterProxy 클래스의 구현을 바꾸면 Printeable 인터페이스에 선언되어 있는 메소드 중에서 무엇을 대리인이 처리하고 무엇을 본인이 처리할 것인지를 변경할 수 있습니다. 게다가 이와 같은 수정을 마무리해도 Printer 클래스 쪽은 수정할 필요가 없습니다. 만약 지연평가를 실행시키고 싶지 않으면, Main 클래스에서 PrinterProxy 클래스의 인스턴스를 new하지 않고 Printer클래스의 인스턴스를 new 하면 됩니다. PrinterProxy 클래스와 Printer클래스 모두 Printable인터페이스를 구현하고 있기 때문에, Main클래스는 안심하고 PrinterProxy 와 Printer를 교체해서 사용할 수 있습니다.



### 대리와 위임

대리인이 혼자 처리할 수 있는 일은 대리인이 처리. 대리인이 처리할 수 없을 때에는 처리할 수 있는 본인에게 '위임'합니다. 이 '위임'은 이 책의 여러 곳에서 등장하는 '위임'으로, PrinterProxy 클래스의 print에서 real.print를 호출하고 있는 바로 그  '위임'입니다.



### 투과적이란?

PrinterProxy 클래스와 Printer클래스는 같은 Printable이란 인터페이스를 구현하고 있습니다. Main 클래스는 실제로 호출하는 곳이 PrinterProxy 클래스이든 Printer 클래스이든 상관하지 않습니다. Printer를 직접 이용해도, 중간에 PrinterProxy가 들어와도 문제없이 사용할 수 있습니다.

이와 같은 경우, PrinterProxy 클래스는 '투과적'이라고 말할 수 있습니다. 여러분과 그림사이에 투명한 유리판이 놓여있어도 그림을 볼 수 있는 것처럼 Main 클래스와 Printer 클래스 사이에 PrinterProxy 클래스가 놓여있어도 문제가 되지 않습니다.

