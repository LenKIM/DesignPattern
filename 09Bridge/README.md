분리해서 생각하기

Bridge - 기능계층과 구현계층 분리하기



`Bridge 패턴`

다리라는 의미의 이 패턴은 현실세계의 다리가 강 양쪽의 장소를 연결하는 역할을 하듯이 Bridge패턴도 두 장소를 연결하는 역할을 합니다.  
Bridge패턴이 다리 역할을 하고 있는 두 곳은 '기능의 클래스 계층'과 '구현의 클래스 계층' 입니다.

'기능의 클래스 계층'과 '구현의 클래스 게층'사이에 다리를 놓는다는 말해도 좀처럼 이해하기 어려울 수 있습니다. Bridge패턴의 예제 프로그램을 읽기 전에 두 가지의 의미를 이해해야 한다.



## 클래스 계층의 두가지 역할

### 새로운 '기능'을 추가하고 싶은 경우

어떤 클래스 Something이 있다고 가정합니다. Something에 새로운 기능을 추가하고 싶을 때(구채적으로는 새로운 메소드를 추가하고 싶을 때), 우리들은 Something의 하위 클래스로 SomethingGood클래스를 만듭니다. 여기에서 작은 클래스 계층이 생성되어습니다.

Something  

​	\- SomethingGood

이것은 기능을 추가하기 위해 만들어진 계층입니다.

- 상위클래스는 기본적인 기능을 가지고 있습니다.
- 하위클래스에서 새로운 기능을 추가한다.

이 클래스 계층을 '기능의 클래스 계층' 이라고 한다.

SomethingGood 클래스에 또 다른 새로운 기능을 추가하려면, SomethingGood클래스의 하위클래스로서 SomethingBetter 클래스를 만듭니다. 이것으로 기능의 클래스 계층이 더욱 깊어졌습니다.

Something

​	\- SomethingGood

​		\- SomethingBetter

새로운 기능을 추가하고 싶을 경우 클래스 계층 안에서 자신의 목적과 가까운 클래스를 찾아내 그 하위클래스를 만들어, 목적한 기능을 추가한 새로운 클래스를 만드는것이 기능의 클래스 계층

### 새로운 '구현'을 추가하고 싶은 경우

템플릿패턴에서 추상클래스의 역할에 대해 배웠다. 추상 클래스가 일련의 메소드들을 추상 메소드로서 선언하고 인터페이스를 규정합니다. 그리고 하위 클래스 측에서 그 추상 메소드를 실제로 구현하고 상위 클래스는 추상메소드로 인터페이스를 규정하는 역할을 하고 하위 클래스는 그것을 구현하는 역할을 합니다. 이와같은 상위 클래스와 하위 클래스의 역할 분담에 의해 부품으로의 가치(교환 가능성)가 높은 클래스를 만들 수 있습니다.

여기에는 클래스 계층이 등장합니다. 예를 들면, 상위 클래스 AbstractClass의 추상 메소드를 구현하는 하위 클래스를 ConcreateClass라 하면, 다음과 같은 소규모의 클래스 계층이 만들어집니다.

AbstractClass

​	\- ConcreateClass

그러나 여기에서 사용되는 클래스 계층은 기능을 추가하기 위한 것도 새로운 메소드를 추가하기 위한 것도 아닙니다. 여기에서는 다음과 같은 역할 분담을 위해 클래스 계층이 사용되고 있습니다.

\- 상위 클래스는 추상 메소드에 의해 인터페이스(API)를 규정한다.  
\- 하위 클래스는 구상 메소드에 의해 그 인터페이스(API)를 구현한다.  

### 클래스 계층의 혼재와 클래스 계층의 분리

우리가 하위클래스를 만들려고 생각할 때, 자신의 의도를 다음과 같이 확인할 필요가 있습니다. '나는 기능을 추가하려고 하는가? 구현을 수행하려고 하는가?' 클래스 계층이 하나라면 기능의 클래스 계층과 구현의 클래스 계층이 하나의 계층구조 안에 혼재하게 됩니다. 이게 클래스 계층을 복잡하게 해서 예측을 어렵할 우려가 있습니다. 자신이 하위 클래스를 만들려고 할 떄 클래스 계층의 어디에 만들면 좋을지 헤매기 십상, 그래서 '기능의 클래스 계층'과 '구현의 클래스 계층'을 **두 개의 독립된 클래스 계층으로 분리**합니다. 단순히 분리만 하면 흩어져버리기 때문에 두 개의 클래스 계층 사이에 다리를 놓는 일이 필요합니다.

그래서 해당 클래스를 공부합니다.
아래 예시를 보면서 이해하기.

```
1. Display -> 여기에 Impl 객체를 생성하고 생성자에 넣음
2. CountDisplay -> 기능계층의 클래스
3. DisplayImpl -> 구현계층의 클래스
4. StringDisplayImpl ->구현계층의 클래스
5. Main
```



## Bridge 패턴의 등장인물

### Abstaction(추상화)의 역할

'기능의 클래스 계층'의 최상위 클래스입니다. Implementor 역할의 메소드를 사용해서 기본적인 기능만이 기술되어 있는 클래스입니다. 이 인스턴스는 Implementor역할을 가지고 있습니다. Display가 이 역할



### RefinedAbstaction(개선된 추상화)역할

Abstraction 역할에 대해 기능을 추가한 역할, 예제에서는 CountDisplay



### Implementor(구현자)의 역할

구현의 최상위 클래스. Abstaction역할의 인터페이스를 구현하기 위한 메소드를 규정하는 역할.
예제 프로그램에서는 DisplayImpl 클래스가 이 역할을 합니다.

### Concreate Implementor(구체적인 구현자)의 역할

인터페이스를 구체적으로 구현하는 역할입니다. 예제 프로그램에서는 StringDIsplayImpl클래스가 이 역할을 합니다.



![](https://ws4.sinaimg.cn/large/006tKfTcgy1fo7n6eb8d7j30cs084dgj.jpg)

![](https://ws1.sinaimg.cn/large/006tKfTcgy1fo7n6hxjcpj30ip0bwwgz.jpg)





## 왜 브릿지패턴을 쓰는가?

#### 1. 분리해 두면 확장이 편해진다.

'기능의 클래스 계층'과 '구현의 클래스 계층'을 분리한다는 건, 각각의 클래스 계층을 독립적으로 확장할 수 있다는 것.

기능을 추가하고 싶으면 기능의 클래스 계층에 클래스를 추가하고, 이때 구현의 클래스 계층은 전혀 수정할 필요가 없습니다. 새로 추가한 기능은 '모든 구현'에서 이용할 수 있습니다.

#### 2. 상속이 견고한 연결이고 위임은 느슨한 연결이다.

'상속'은 클래스를 확장하기 위해 편리한 방법이지만 클래스간의 연결을 강하게 고정시킵니다. 소스코드 상에서

```Java
Class SomethingGood extends Something{
  ...
}
```

라고 쓰면 SomethingGood 클래스는 Something 클래스의 하위 클래스가 됩니다. 그리고 이 관계는 소스코드를 고쳐 쓰지 않는 한 바꿀 수 없는 매우 견고한 연결이 됩니다. 프로그램의 필요에 따라서 클래스 간의 관계를 척척 바꾸고 싶을 떄에 상속을 사용하는 것은 부적절합니다. 교체할 때마다 소스코드를 변경할 수 없기 때문입니다. 이와 같은 경우에는 '상속'이 아니라 '위임'을 사용합니다.

예제 프로그램에서는 Display클래스 내에서 위임이 사용되고 있습니다. Display클래스의 imple필드에는 구현되는 인스턴스가 저장되어 있어서

\- open을 실행할 때에는 impl.rawOpen()을 호출  
\- print을 실행할 때에는 impl.rawPrint()을 호출  
\- close을 실행할 때에는 impl.rawClose()을 호출

라는 식으로 "떠넘기기"를 하고 있다. 이것이 위임. 상속은 견고한 연결이고 위임은 느슨한 연결입니다. Display클래스의 인스턴스를 만드는 단게에서 인수로 전달되어 온 것과 연결되기 때문입니다. Main 클래스 내에서 Display나 CountDisplay의 인스턴스를 만들고 그때 StringDisplayImpl의 인스턴스를 인수에게 전달했습니다.