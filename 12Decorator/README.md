# 개요

스펀지 케이크가 1개 있다고 가정하빈다. 크림을 바르면 아무 모양이 없는 크림 케이크가 됩니다. 여기에 딸기를 얹으면 딸기 케이크가 되고, 초콜릿으로 장식을 하고 이름을 쓰고 나이 수만큼 초를 꽂으면 생일 케이크가 됩니다.

스펀지 케이크도, 크림 케이크도, 딸기 케이크도, 생일 케이크도 처음에는 다 같은 스펀지 케이크입니다. 그러나 크림을 발고 딸기를 얹는 등 다양한 장식을 하면 더욱 맛있고 각각의 모적에 어울리는 케이크가 됩니다.

오브젝트(객체)도 이런 케이크와 비슷한 경우가 있습니다. 우선 스펀지 케이크와 같은 중심이 되는 오브젝트가 있습니다. 이 오브젝트에 장식이 되는 기능을 하나씩 추가하면 좀더 목적에 맞는 오브젝트가 완성됩니다. 이와 같이 오브젝트에 장식을 내 나가는 디제인 패턴을 

> Decorator 패턴

이라고 합니다. decorator는 'decorate(장식)을 하는 것' 이라는 의밍비니다.

예제에서의 클래스 종류

Display => 문자열 포시용의 추상 클래스  
StringDisplay => 1행으로 구성된 문자열 표시용의 클래스  
Border => '장식'을 나타내는 클래스  
SlideBorder => 좌우에 장식을 붙이는 클래스  
FullBorder => 상하좌우에 장식을 붙이는 클래스  
Main => 동작 테스트용의 클래스  

## Ex) 에디터

## Decorator 패턴의 등장인물

### Component의 역할

기능을 추가할 때 핵심이 되는 역할. 서두의 케이크에 비교하면 장식하기 전의 스펀지 케이크에 해당합니다. Component역할은 스펀지 케이크의 인터페이스(API)만을 결정합니다.

### ConcreateComponent의 역할

Component 역할의 인스턴스(API)를 구현하고 있는 구체적인 스펀지 케이크입니다. 예제 프로그램에서는 StringDIsplay 클래스가 이 역할을 합니다.

### Decorator(장식자)의 역할

Component역할과 동일한 인터페이스(API)를 가지며, 또한 이 Decorator 역할이 장식할 대상이 되는 Component역할도 가지고 있습니다. 이 역할은 자신이 장식하고 있는 대상을 알고 있습니다. 예제 프로그램에서는 Border클래스가 이역할을 합니다.

### ConcreateDecorator(구체적인 장식자)의 역할

구체적인 Decorator의 역할, 예제에서는 SideBorder클래스와 Fullborder클래스가 이 역할을 수행함.



## 독자의 사고를 넓히기 위한 힌트

### 투과적인 인터페이스(API)

Decorator 패턴에서는 장식과 내용물을 동일시하고 있습니다. 구체적으로 말하면 예제 프로그램에서 장식을 나타내는 Border클래스, 내용물을 나타내는 Display 클래스의 하위 클래스로 되어 있는 곳에서 동일하게 표현되고 있습니다. 즉, Border, 클래스(및 그 하위 클래스들)는 내용물을 나타내는 Display 클래스와 동일한 인터페이스(API)를 가집니다.

장식을 사용해서 내용물을 감싸도 인터페이스(API)는 전혀 감출 수 없습니다. getColumns, getRows, getrowText, show라는 메소드는 감추어지는 일없이 다른 클래스에서 볼 수 있습니다. 이것을 인터페이스(API)가 '투가적'이라고 합니다. 예제프로그램의 인스턴스 b4와 같이 장식을 많이 사용해서 포함해도 인터페이스(API)는 전혀 바꾸지 않습니다.

인터페이스(API)가 투과적이기 때문에 Decorator 패턴에서는 Composite패턴과 닮은 재귀적인 구조가 등장합니다. 즉, 장식이 둘러싸고 있는 '내용물'이 실제로는 다른  '장식'이 되는 구조입니다. "양파의 껍질을 벗겨 알맹이가 나왔다고 생각했더니 그것 또한 껍질이었다"같은 것입니다. "양파의 껍질을 벗겨 알맹이가 나왔다고 생각했더니 그것 또한 껍질이었다"같은 것입니다. Decorator 패턴과 Composite 패턴은 재귀적인 구조를 취하는 점에서는 유사하지만 목적은 다릅니다. Decorator 패턴은 테두리 장식을 중복해서 기능을 추가해가는 것에 주안점을 두기 때문입니다.

### 내용물을 바꾸지 않고 기능을 추가할 수 있다.

Decorator 패턴에서는 장식도 내용물도 공통의 인터페이스(aPI)를 가집니다. 인터페이스(API)는 공통이지만, 장식하면 장식할수록 기능이 추가됩니다. Display를 SideBorder로 감싸면 좌우에 새로운 장식문자를 표시할 수 있습니다. 그리고 FullBorder로 감싸면 가장자리 전체에 장식을 붙일 수 있습니다. 이때, 장식되는 상대(내용물)는 수정할 필요가 없습니다. **즉, 내용물을 변경하지 않고 기능을 추가할 수 있습니다.**

Decorator 패턴에서는 **위임**을 사용하고 있습니다. '장식'에 대한 요구(메소드의 호출)는 그 '내용물'에 떠넘겨(위임)집니다. 예제에서는 SideBorder의 getColumns메소드안에서 display.getColumns()를 호출하며, getRows 메서드에서는 display.getRow()를 호출하고 있습니다.

### 동적인 기능을 추가할 수 있다.

Decorator 패턴에서 사용되는 위임은 클래스 사이를 느슨하게 결합합니다. 따라서 framework의 소스를 변경하지 않고 오브젝트(객체)의 관계를 변경한 새로운 오브젝트(객체)를 만들 수 있습니다.

### 단순한 장식이라도 다양한 기능을 추가할 수 있다.

Decorator패턴을 사용하면 다양한 기능을 추가할 수 있습니다. 구체적인 장식(Concreate Decorator 역할)을 많이 준비해 두면, 그것들을 자유롭게 조합해서 새로운 오브젝트를 만들 수 있기 때문입니다. 이때, 각각의 장식은 단순해도 상관없습니다.

이것은 바닐라, 초콜릿,딸기, 키위 등의 장식을 자유롭게 서내갛ㄹ 수 있는 아이스크림과 같습니다. 손님이 주문할지, 안 할지 알 수 없는 여러 가지 아이스크림을 처음부터 전부 준비해야 한다면 주문을 받는 입장에서 큰 부담이 될 것입니다. 가게에서는 다양한 종류의 장식을 준비해 두었다가 손님의 주문에 따라 장식을 해서 손님이 주문한 아이스크름을 만듭니다. Decorator 패턴은 이와같은 다양한 요구에 적합

### Java.io 패키지와 Decorator 패턴

> Reader reader = new FileReader("datafile.txt");



### 작은 클래스가 증가한다.

Decorator 패턴을 사용하면 매우 유사한 성질의 작은 클래스가 많이 만들어지는 결점이 있다.
