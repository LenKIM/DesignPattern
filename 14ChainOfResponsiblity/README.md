## Chain of Responsibility 패턴

복수의 오브젝트(객체)를 사실(chain)처럼 연결해 두면, 그 오브젝트(객체)의 사슬을 차례로 돌아다니면서 목적한 오브젝트(객체)를 결정하는 방법을 생각할 수 있다.

이와 같은 패턴을 **Chain of Responsibility 패턴**

**'책임을 떠넘기는'** 구조를 생각하면 이해하기 쉬움

이 패턴을 사용하면 '요청하는 쪽'과 '처리하는 쪽'의 연결을 유연하게 해서 각 오브젝트를 부품으로 독립시킬 수 있습니다. 또한 상황에 따라서 요청을 처리할 프로젝트가 변하는 프로그램도 대응할 수 있다.

어떤 사람에게 요구를 합니다. 그 사람이 그것을 처리할 수 있으면 처리하고, 처리할 수 없으면 그 요구를 '다음 사람'에게 넘깁니다. 다음 사람이 그 요구를 처리할 수 있으면 처리하고, 처리할 수 없으면 '또 다른 사람'에게 책임을 넘깁니다.



> 예제
>
> 트러블이 발생해서 누군가 처리해야 하는 상황을 생각해 봅시다.

| 이름           | 해설                                                         |
| -------------- | ------------------------------------------------------------ |
| Trouble        | 발생한 트러블을 나타내는 클래스, 트러블 번호(number)를 가진다. |
| Support        | 트러블을 해결하는 추상 클래스                                |
| NoSupport      | 트러블을 해결하는 구상 클래스(항상 처리하지 않는다.)         |
| LimitSupport   | 트러블을 해결하는 구상 클래스(지정한 번호 미만의 트러블을 해결) |
| SpecialSupport | 트러블을 해결하는 구상 클래스(홀수 번호의 트러블을 해결)     |
| SpecialSupport | 트러블을 해결하는 구상 클래스(특정 번호의 트러블을 해결)     |
| Main           | Support들의 사슬을 만들고 트러블을 발생시키는 동작 테스트용 클래스 |



**Handle(처리자)의 역할**
handler는 요구를 처리하는 인터페이스를 결정하는 역할을 합니다. '다음 사람'을 준비해두고 자신이 처리할 수 없는 요구가 나오면 그 사람에게 떠넘기기를 합니다. 물론 '다음 사람'도 handler역할입니다. 예제 프로그램에서는 Support클래스가 이 역할을 합니다. 요구를 처리하는 메소드는 support메소드였습니다.

**ConcreateHandler(구체적인 처리자)의 역할**



**Client(요구자)의 역할**

Main 함수

![http://www.dofactory.com/images/diagrams/net/chain.gif](http://www.dofactory.com/images/diagrams/net/chain.gif)



## 독자 사고 넓히기

### 1. 요구하는 사람과 요구를 처리하는 사람을 유연하게 연결

Chain of  Responsibility 패턴의 포인트는 요구를 하는 사람과 요구를 처리하는 사람을 유연하게 연결하는 것입니다. Client 역할은 최초의 사람에게 요구를 합니다. 그러면 뒷일은 사슬 안으로 그 요구가 전달되어 적절한 처리자에 의해 요구가 처리됩니다.



만약, 이 패턴을 사용하지 않으면 '이 요구는 이 사람이 처리해야 한다'라는 정보를 누군가가 중앙집권적으로 가지고 있어야 합니다. 그 정보를  '요구를 하는 사람'에게 갖게 하는 것은 별로 현명하지 않습니다. 요구를 하는 사람이 처리자들의 역할 분담까지 자세하게 알아야 한다면 부품으로써 독립성이 훼손되기 때문입니다.

### 2. 동적으로 사슬의 형태를 바꾼다

### 3. 자신의 일에 집중할 수 있다.

### 4. 떠넘기기로 처리가 지연되지 않을까?

트레이드 오프문제이다.



## 연습문제

1. 원도우 시스템에서는 Chain of Responsibility 패턴이 자주 사용됨. 원도우 상에서는 버튼이나 텍스트 박스, 체크 박스 등의 컴포넌트가 탑재되어 있습니다. 마우스를 클릭할 때 생기는 이벤트는 어떻게 넘겨질까요? Chain of Responsiblity 패턴에서 'next'(떠넘기기 할 곳)은 어디에 등장할까요? 

   **부모 윈도우가 'next'로 된다.** 컴포넌트에 전달된 이벤트는 그 컴포넌트에서 처리하지 않을 때, 순서대로 부모 원도우로 전달됩니다.

2.  

3. 예제 프로그램의 Support 클래스에서 Support 메소드는 public 으로 되어 있지만, resolve 메소드는 protected로 되어 있다. 이렇게 구분한 설계자의 의도는 무엇일까?

   ​

   ​

4. 예제 프로그램의 support 메소드를 재귀적으로 호출하지 말고 루프로 전개해 봅시다.

```
for(Support obj= this; true; obj= obj.next){
    if(obj.resolve(trouble)){
        obj.done(trouble);
        break;
    } else if(obj.next == null){
        obj.fail(trouble);
        break;
    }
}
```

